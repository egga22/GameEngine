<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GameForge 2D - Visual Game Engine</title>
    <style>
        /* ===== CSS Variables & Reset ===== */
        :root {
            --bg-dark: #1a1a2e;
            --bg-panel: #16213e;
            --bg-lighter: #1f3460;
            --bg-input: #0f0f1a;
            --accent: #e94560;
            --accent-hover:  #ff6b6b;
            --accent-secondary: #0f3460;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --border-color: #2a2a4a;
            --success: #4ecca3;
            --warning: #ffc107;
            --danger:  #e94560;
            --node-event: #4ecca3;
            --node-action: #e94560;
            --node-flow: #ffc107;
            --node-math: #7b68ee;
            --node-comparison: #ff9800;
            --node-variable: #00bcd4;
            --grid-color: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background:  var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }

        /* ===== App Layout ===== */
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* ===== Toolbar ===== */
        #toolbar {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 8px 16px;
            background: var(--bg-panel);
            border-bottom: 2px solid var(--border-color);
            flex-shrink:  0;
            flex-wrap: wrap;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo {
            font-size: 20px;
            font-weight:  bold;
            color: var(--accent);
            margin-right: 10px;
        }

        button {
            padding: 6px 12px;
            background: var(--bg-lighter);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius:  4px;
            cursor:  pointer;
            font-size:  13px;
            transition:  all 0.2s;
        }

        button:hover {
            background: var(--accent-secondary);
            border-color:  var(--accent);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.active {
            background: var(--accent);
            border-color: var(--accent);
        }

        .play-btn: hover {
            background: var(--success) !important;
            color: #000 !important;
        }

        .stop-btn:hover:not(:disabled) {
            background: var(--danger) !important;
        }

        /* ===== Main Content ===== */
        #main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* ===== Panels ===== */
        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
        }

        .panel-header {
            padding: 10px 15px;
            background: var(--bg-lighter);
            border-bottom: 1px solid var(--border-color);
            font-weight: bold;
            font-size: 14px;
        }

        /* Left Panel - Palette */
        #left-panel {
            width: 220px;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            background: var(--bg-panel);
        }

        #palette-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
        }

        .palette-tab {
            flex: 1;
            padding:  8px;
            background: var(--bg-dark);
            border:  none;
            border-radius: 0;
            font-size: 12px;
        }

        .palette-tab.active {
            background: var(--bg-lighter);
        }

        #palette-content {
            flex:  1;
            overflow-y: auto;
            padding:  10px;
        }

        .palette-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            margin-bottom: 8px;
            background: var(--bg-dark);
            border:  1px solid var(--border-color);
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s;
        }

        .palette-item:hover {
            border-color: var(--accent);
            transform: translateX(3px);
        }

        .palette-item:active {
            cursor: grabbing;
        }

        .palette-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border-radius: 4px;
        }

        .palette-info {
            flex: 1;
        }

        .palette-info h4 {
            font-size: 13px;
            margin-bottom:  2px;
        }

        .palette-info span {
            font-size: 10px;
            color: var(--text-secondary);
        }

        /* Center Panel - Canvas */
        #center-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            background: var(--bg-dark);
        }

        .editor-view {
            display: none;
            flex:  1;
            position: relative;
        }

        .editor-view.active {
            display: flex;
            flex-direction: column;
        }

        #canvas-container {
            flex:  1;
            overflow: hidden;
            position: relative;
        }

        #game-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid var(--border-color);
            background:  #0a0a15;
        }

        #canvas-controls {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            padding: 8px 15px;
            background: rgba(22, 33, 62, 0.9);
            border-radius: 25px;
            border: 1px solid var(--border-color);
        }

        #canvas-controls button {
            padding: 5px 10px;
            font-size: 12px;
        }

        #zoom-level {
            min-width: 50px;
            text-align: center;
            line-height: 28px;
        }

        /* Node Editor */
        #node-editor-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: 
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size:  20px 20px;
        }

        #node-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #node-toolbar {
            padding: 10px 15px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        #node-toolbar select {
            padding: 6px 10px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 4px;
            min-width: 150px;
        }

        #node-info {
            padding: 8px 15px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-color);
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Right Panel - Inspector */
        #right-panel {
            width: 280px;
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--border-color);
            background: var(--bg-panel);
        }

        #inspector {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .inspector-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .inspector-section h3 {
            font-size: 13px;
            margin-bottom:  12px;
            color: var(--accent);
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .property-row label {
            width: 80px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .property-row input[type="text"],
        .property-row input[type="number"],
        .property-row select {
            flex: 1;
            padding:  6px 10px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius:  4px;
            font-size: 12px;
        }

        .property-row input[type="color"] {
            flex: 1;
            height: 30px;
            padding: 2px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
        }

        .property-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .property-row input[type="range"] {
            flex: 1;
        }

        .full-width-btn {
            width: 100%;
            margin-top: 8px;
            padding: 10px;
        }

        .danger {
            background: var(--danger);
            border-color: var(--danger);
        }

        .danger:hover {
            background: #ff6b6b;
        }

        #no-selection {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        /* ===== Bottom Panel ===== */
        #bottom-panel {
            height: 150px;
            background: var(--bg-panel);
            border-top: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .panel-tabs {
            display: flex;
            background: var(--bg-dark);
            border-bottom: 1px solid var(--border-color);
        }

        .panel-tab {
            padding: 8px 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .panel-tab.active {
            background: var(--bg-panel);
            color: var(--text-primary);
            border-bottom: 2px solid var(--accent);
        }

        .bottom-content {
            display: none;
            flex: 1;
            overflow: hidden;
        }

        .bottom-content.active {
            display: flex;
            flex-direction: column;
        }

        #console-output {
            flex: 1;
            overflow-y: auto;
            padding:  10px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            background: var(--bg-dark);
        }

        .console-line {
            padding: 3px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .console-line.error {
            color: var(--danger);
        }

        .console-line.warn {
            color: var(--warning);
        }

        .console-line.success {
            color: var(--success);
        }

        #console-input-row {
            display: flex;
            padding: 8px;
            gap: 8px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-color);
        }

        #console-input {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color:  var(--text-primary);
            border-radius: 4px;
            font-family: 'Consolas', monospace;
        }

        #hierarchy-list {
            flex: 1;
            overflow-y: auto;
            padding:  10px;
        }

        .hierarchy-item {
            padding: 8px 12px;
            margin-bottom:  4px;
            background: var(--bg-dark);
            border: 1px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
        }

        .hierarchy-item:hover {
            border-color: var(--border-color);
        }

        .hierarchy-item.selected {
            border-color: var(--accent);
            background:  var(--accent-secondary);
        }

        #settings-content {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            padding: 15px;
            overflow-y: auto;
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .setting-item label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .setting-item input {
            padding: 8px 10px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color:  var(--text-primary);
            border-radius: 4px;
        }

        /* ===== Visual Script Nodes ===== */
        .vs-node {
            position: absolute;
            min-width: 180px;
            background: var(--bg-panel);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: move;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .vs-node.selected {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.3);
        }

        .vs-node-header {
            padding: 10px 12px;
            border-radius: 6px 6px 0 0;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .vs-node.event .vs-node-header { background: var(--node-event); color: #000; }
        .vs-node.action .vs-node-header { background: var(--node-action); }
        .vs-node.flow .vs-node-header { background: var(--node-flow); color: #000; }
        .vs-node.math .vs-node-header { background: var(--node-math); }
        .vs-node.comparison .vs-node-header { background: var(--node-comparison); color: #000; }
        .vs-node.variable .vs-node-header { background: var(--node-variable); color: #000; }

        .vs-node-content {
            padding: 10px;
        }

        .vs-node-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .vs-node-row: last-child {
            margin-bottom: 0;
        }

        .vs-port {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid var(--text-primary);
            background: var(--bg-dark);
            cursor: crosshair;
            transition: all 0.2s;
        }

        .vs-port:hover {
            transform: scale(1.3);
            background: var(--accent);
        }

        .vs-port.exec {
            border-radius: 3px;
            transform: rotate(45deg);
        }

        .vs-port.exec:hover {
            transform: rotate(45deg) scale(1.3);
        }

        .vs-port.connected {
            background: var(--accent);
        }

        .vs-port-label {
            font-size:  10px;
            color:  var(--text-secondary);
        }

        .vs-node input {
            width: 60px;
            padding: 4px 6px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius:  3px;
            font-size: 11px;
        }

        .vs-node select {
            padding: 4px 6px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 3px;
            font-size: 11px;
        }

        /* ===== Scrollbar ===== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background:  var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-lighter);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }

        /* ===== Modal ===== */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-panel);
            border: 2px solid var(--border-color);
            border-radius:  12px;
            padding: 25px;
            min-width: 400px;
            max-width:  90%;
        }

        .modal h2 {
            margin-bottom: 20px;
            color: var(--accent);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top:  20px;
            justify-content: flex-end;
        }

        /* ===== Play Mode Overlay ===== */
        #play-overlay {
            display: none;
            position: fixed;
            top: 0;
            left:  0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #play-overlay.active {
            display: flex;
        }

        #play-canvas {
            border: 3px solid var(--accent);
            border-radius: 8px;
        }

        #play-controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        /* ===== Context Menu ===== */
        #context-menu {
            display: none;
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 150px;
            z-index: 1001;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
        }

        #context-menu.active {
            display: block;
        }

        .context-item {
            padding:  10px 20px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-item:hover {
            background: var(--accent-secondary);
        }

        .context-divider {
            height: 1px;
            background: var(--border-color);
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Top Toolbar -->
        <div id="toolbar">
            <div class="toolbar-section">
                <span class="logo">üéÆ GameForge 2D</span>
            </div>
            <div class="toolbar-section">
                <button id="btn-new" title="New Project">üìÑ New</button>
                <button id="btn-save" title="Save Project">üíæ Save</button>
                <button id="btn-load" title="Load Project">üìÇ Load</button>
                <input type="file" id="file-input" accept=".json" style="display: none;">
            </div>
            <div class="toolbar-section">
                <button id="btn-play" class="play-btn" title="Play Game">‚ñ∂Ô∏è Play</button>
                <button id="btn-stop" class="stop-btn" title="Stop Game" disabled>‚èπÔ∏è Stop</button>
            </div>
            <div class="toolbar-section">
                <button id="btn-grid" title="Toggle Grid">üî≤ Grid</button>
                <button id="btn-snap" class="active" title="Toggle Snap">üß≤ Snap</button>
            </div>
            <div class="toolbar-section">
                <button id="tab-scene" class="active">üé¨ Scene</button>
                <button id="tab-visual">üîó Visual Script</button>
            </div>
            <div class="toolbar-section">
                <span id="status-text" style="font-size: 12px; color: var(--text-secondary);">Ready</span>
            </div>
        </div>

        <!-- Main Content -->
        <div id="main-content">
            <!-- Left Panel -->
            <div id="left-panel">
                <div class="panel-header">üì¶ Objects</div>
                <div id="palette-tabs">
                    <button class="palette-tab active" data-tab="objects">Objects</button>
                    <button class="palette-tab" data-tab="prefabs">Prefabs</button>
                </div>
                <div id="palette-content"></div>
            </div>

            <!-- Center Panel -->
            <div id="center-panel">
                <!-- Scene View -->
                <div id="scene-view" class="editor-view active">
                    <div id="canvas-container">
                        <canvas id="game-canvas"></canvas>
                    </div>
                    <div id="canvas-controls">
                        <button id="btn-zoom-in">‚ûï</button>
                        <span id="zoom-level">100%</span>
                        <button id="btn-zoom-out">‚ûñ</button>
                        <button id="btn-zoom-reset">‚Ü∫</button>
                    </div>
                </div>

                <!-- Visual Script View -->
                <div id="visual-script-view" class="editor-view">
                    <div id="node-toolbar">
                        <span>Add Node: </span>
                        <select id="node-type-select">
                            <optgroup label="Events">
                                <option value="OnStart">On Start</option>
                                <option value="OnUpdate">On Update</option>
                                <option value="OnKeyPress">On Key Press</option>
                                <option value="OnKeyRelease">On Key Release</option>
                                <option value="OnCollision">On Collision</option>
                                <option value="OnClick">On Mouse Click</option>
                            </optgroup>
                            <optgroup label="Actions">
                                <option value="Move">Move</option>
                                <option value="SetPosition">Set Position</option>
                                <option value="SetVelocity">Set Velocity</option>
                                <option value="ApplyForce">Apply Force</option>
                                <option value="Rotate">Rotate</option>
                                <option value="Destroy">Destroy</option>
                                <option value="Spawn">Spawn Object</option>
                                <option value="PlaySound">Play Sound</option>
                                <option value="Log">Log Message</option>
                            </optgroup>
                            <optgroup label="Flow Control">
                                <option value="Branch">Branch (If/Else)</option>
                                <option value="Delay">Delay</option>
                                <option value="Loop">Loop</option>
                            </optgroup>
                            <optgroup label="Math">
                                <option value="Add">Add</option>
                                <option value="Subtract">Subtract</option>
                                <option value="Multiply">Multiply</option>
                                <option value="Divide">Divide</option>
                                <option value="Random">Random</option>
                            </optgroup>
                            <optgroup label="Comparison">
                                <option value="Equals">Equals</option>
                                <option value="Greater">Greater Than</option>
                                <option value="Less">Less Than</option>
                            </optgroup>
                            <optgroup label="Variables">
                                <option value="GetVariable">Get Variable</option>
                                <option value="SetVariable">Set Variable</option>
                                <option value="GetProperty">Get Property</option>
                            </optgroup>
                        </select>
                        <button id="btn-add-node">‚ûï Add Node</button>
                        <button id="btn-clear-nodes">üóëÔ∏è Clear All</button>
                        <span style="margin-left: auto; font-size: 12px; color: var(--text-secondary);" id="current-object-script">No object selected</span>
                    </div>
                    <div id="node-editor-container">
                        <svg id="connection-svg"></svg>
                    </div>
                    <div id="node-info">
                        üí° Drag from ports to connect nodes ‚Ä¢ Right-click node to delete ‚Ä¢ Drag to move nodes
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div id="right-panel">
                <div class="panel-header">üîß Inspector</div>
                <div id="inspector">
                    <div id="no-selection">
                        <p>üëÜ Select an object to edit its properties</p>
                        <p style="margin-top: 15px; font-size: 11px;">Drag objects from the left panel onto the canvas to create them</p>
                    </div>
                    <div id="object-inspector" style="display: none;"></div>
                </div>
            </div>
        </div>

        <!-- Bottom Panel -->
        <div id="bottom-panel">
            <div class="panel-tabs">
                <button class="panel-tab active" data-panel="console">üìù Console</button>
                <button class="panel-tab" data-panel="hierarchy">üìã Hierarchy</button>
                <button class="panel-tab" data-panel="settings">‚öôÔ∏è Settings</button>
            </div>
            <div id="console-panel" class="bottom-content active">
                <div id="console-output"></div>
                <div id="console-input-row">
                    <input type="text" id="console-input" placeholder="Enter command... ">
                    <button id="btn-console-clear">Clear</button>
                </div>
            </div>
            <div id="hierarchy-panel" class="bottom-content">
                <div id="hierarchy-list"></div>
            </div>
            <div id="settings-panel" class="bottom-content">
                <div id="settings-content"></div>
            </div>
        </div>
    </div>

    <!-- Play Mode Overlay -->
    <div id="play-overlay">
        <canvas id="play-canvas"></canvas>
        <div id="play-controls">
            <button id="btn-stop-play">‚èπÔ∏è Stop Game</button>
            <button id="btn-restart-play">üîÑ Restart</button>
        </div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-item" data-action="duplicate">üìã Duplicate</div>
        <div class="context-item" data-action="delete">üóëÔ∏è Delete</div>
        <div class="context-divider"></div>
        <div class="context-item" data-action="bring-front">‚¨ÜÔ∏è Bring to Front</div>
        <div class="context-item" data-action="send-back">‚¨áÔ∏è Send to Back</div>
    </div>

    <script>
        // ==========================================
        // GAME FORGE 2D ENGINE - COMPLETE SOURCE
        // ==========================================

        // ===== GLOBAL STATE =====
        const Engine = {
            canvas: null,
            ctx: null,
            width: 800,
            height:  600,
            backgroundColor: '#1a1a2e',
            gridSize: 32,
            showGrid: true,
            snapToGrid: true,
            zoom: 1,
            panX: 0,
            panY: 0,
            isPlaying: false,
            selectedObject: null,
            objects: [],
            prefabs: [],
            variables: {},
            gravity: { x: 0, y: 980 },
            nextId: 1,
            deltaTime: 0,
            lastTime: 0,
            keys: {},
            mouse: { x: 0, y: 0, down: false }
        };

        // ===== OBJECT PALETTE DEFINITIONS =====
        const PaletteObjects = [
            { type: 'player', name: 'Player', icon: 'üßë', color: '#4ecca3', width: 32, height: 48, physics: true, tag: 'player' },
            { type: 'enemy', name: 'Enemy', icon: 'üëæ', color: '#e94560', width: 32, height: 32, physics: true, tag: 'enemy' },
            { type: 'platform', name: 'Platform', icon: 'üü´', color: '#8b4513', width: 128, height: 32, physics:  true, isStatic: true, tag: 'platform' },
            { type: 'ground', name: 'Ground', icon: 'üü©', color: '#228b22', width: 800, height: 32, physics:  true, isStatic: true, tag: 'ground' },
            { type: 'box', name: 'Box', icon: 'üì¶', color: '#daa520', width: 32, height: 32, physics: true, tag: 'none' },
            { type: 'spike', name: 'Spike', icon: 'üî∫', color: '#ff4444', width: 32, height:  32, physics: true, isStatic: true, tag: 'obstacle' },
            { type: 'coin', name: 'Coin', icon: 'ü™ô', color: '#ffd700', width: 24, height: 24, physics:  false, tag: 'collectible' },
            { type:  'spring', name: 'Spring', icon: 'ü¶ò', color: '#ff69b4', width: 32, height: 16, physics: true, isStatic: true, tag: 'trigger' },
            { type: 'checkpoint', name: 'Checkpoint', icon: 'üö©', color: '#00ff00', width: 32, height: 64, physics: false, tag: 'trigger' },
            { type: 'portal', name: 'Portal', icon: 'üåÄ', color: '#9400d3', width: 48, height: 64, physics: false, tag: 'trigger' },
            { type: 'text', name: 'Text', icon: 'üìù', color: '#ffffff', width: 100, height: 30, physics: false, text: 'Text', tag: 'none' },
            { type: 'rect', name: 'Rectangle', icon: '‚¨ú', color: '#6c5ce7', width: 64, height: 64, physics: false, tag: 'none' },
            { type: 'circle', name: 'Circle', icon: 'üîµ', color: '#0984e3', width: 48, height: 48, isCircle: true, physics: false, tag: 'none' },
            { type: 'trigger-zone', name: 'Trigger Zone', icon: 'üî≤', color: 'rgba(255,255,0,0.3)', width: 100, height: 100, physics:  false, tag: 'trigger' }
        ];

        // ===== GAME OBJECT CLASS =====
        class GameObject {
            constructor(config = {}) {
                this.id = Engine.nextId++;
                this.name = config.name || `Object_${this.id}`;
                this.type = config.type || 'rect';
                this.x = config.x || 100;
                this.y = config.y || 100;
                this.width = config.width || 64;
                this.height = config.height || 64;
                this.rotation = config.rotation || 0;
                this.color = config.color || '#6c5ce7';
                this.opacity = config.opacity !== undefined ? config.opacity : 1;
                this.visible = config.visible !== undefined ? config.visible : true;
                this.layer = config.layer || 0;
                this.tag = config.tag || 'none';
                this.icon = config.icon || '‚¨ú';
                this.text = config.text || '';
                this.isCircle = config.isCircle || false;

                // Physics properties
                this.physics = config.physics || false;
                this.isStatic = config.isStatic || false;
                this.mass = config.mass || 1;
                this.friction = config.friction || 0.1;
                this.bounce = config.bounce || 0.2;
                this.gravityScale = config.gravityScale || 1;

                // Runtime physics state
                this.vx = 0;
                this.vy = 0;
                this.ax = 0;
                this.ay = 0;
                this.grounded = false;

                // Visual scripting
                this.nodes = [];
                this.connections = [];
                this.variables = {};

                // State for play mode
                this.initialState = null;
            }

            saveState() {
                this.initialState = {
                    x: this.x, y: this.y,
                    vx: this.vx, vy: this.vy,
                    rotation: this.rotation,
                    visible: this.visible
                };
            }

            restoreState() {
                if (this.initialState) {
                    Object.assign(this, this.initialState);
                    this.vx = 0;
                    this.vy = 0;
                    this.ax = 0;
                    this.ay = 0;
                }
            }

            getBounds() {
                return {
                    left: this.x,
                    right: this.x + this.width,
                    top: this.y,
                    bottom: this.y + this.height,
                    centerX: this.x + this.width / 2,
                    centerY: this.y + this.height / 2
                };
            }

            containsPoint(px, py) {
                if (this.isCircle) {
                    const cx = this.x + this.width / 2;
                    const cy = this.y + this.height / 2;
                    const r = this.width / 2;
                    return Math.sqrt((px - cx) ** 2 + (py - cy) ** 2) <= r;
                }
                return px >= this.x && px <= this.x + this.width &&
                       py >= this.y && py <= this.y + this.height;
            }

            collidesWith(other) {
                const a = this.getBounds();
                const b = other.getBounds();
                return a.left < b.right && a.right > b.left &&
                       a.top < b.bottom && a.bottom > b.top;
            }

            render(ctx) {
                if (! this.visible) return;

                ctx.save();
                ctx.globalAlpha = this.opacity;

                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;

                if (this.rotation !== 0) {
                    ctx.translate(cx, cy);
                    ctx.rotate(this.rotation * Math.PI / 180);
                    ctx.translate(-cx, -cy);
                }

                if (this.type === 'text') {
                    ctx.fillStyle = this.color;
                    ctx.font = `${this.height}px Arial`;
                    ctx.textBaseline = 'top';
                    ctx.fillText(this.text || 'Text', this.x, this.y);
                } else if (this.isCircle) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, this.width / 2, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }

                // Draw icon
                if (this.icon && this.type !== 'text') {
                    ctx.font = `${Math.min(this.width, this.height) * 0.6}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.icon, cx, cy);
                }

                ctx.restore();
            }

            toJSON() {
                return {
                    id: this.id,
                    name: this.name,
                    type: this.type,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    rotation: this.rotation,
                    color: this.color,
                    opacity: this.opacity,
                    visible: this.visible,
                    layer: this.layer,
                    tag: this.tag,
                    icon: this.icon,
                    text: this.text,
                    isCircle: this.isCircle,
                    physics: this.physics,
                    isStatic: this.isStatic,
                    mass: this.mass,
                    friction: this.friction,
                    bounce: this.bounce,
                    gravityScale: this.gravityScale,
                    nodes: this.nodes,
                    connections: this.connections,
                    variables: this.variables
                };
            }

            static fromJSON(json) {
                const obj = new GameObject(json);
                obj.id = json.id;
                obj.nodes = json.nodes || [];
                obj.connections = json.connections || [];
                obj.variables = json.variables || {};
                return obj;
            }
        }

        // ===== VISUAL SCRIPT NODE DEFINITIONS =====
        const NodeDefinitions = {
            // Events
            OnStart: { category: 'event', color: '#4ecca3', outputs: [{ name: 'exec', type: 'exec' }] },
            OnUpdate:  { category: 'event', color: '#4ecca3', outputs: [{ name: 'exec', type: 'exec' }, { name: 'deltaTime', type: 'number' }] },
            OnKeyPress: { category: 'event', color: '#4ecca3', inputs: [{ name: 'key', type: 'key', default: 'Space' }], outputs: [{ name: 'exec', type: 'exec' }] },
            OnKeyRelease: { category: 'event', color: '#4ecca3', inputs: [{ name: 'key', type: 'key', default: 'Space' }], outputs: [{ name: 'exec', type: 'exec' }] },
            OnCollision: { category: 'event', color: '#4ecca3', inputs: [{ name: 'tag', type: 'tag', default: 'any' }], outputs: [{ name: 'exec', type: 'exec' }, { name: 'other', type: 'object' }] },
            OnClick: { category: 'event', color: '#4ecca3', outputs: [{ name: 'exec', type: 'exec' }] },

            // Actions
            Move: { category: 'action', color: '#e94560', inputs: [{ name: 'exec', type: 'exec' }, { name: 'x', type: 'number', default: 0 }, { name: 'y', type: 'number', default: 0 }], outputs: [{ name:  'exec', type: 'exec' }] },
            SetPosition: { category: 'action', color: '#e94560', inputs: [{ name: 'exec', type: 'exec' }, { name: 'x', type: 'number', default: 0 }, { name: 'y', type: 'number', default: 0 }], outputs: [{ name: 'exec', type: 'exec' }] },
            SetVelocity: { category: 'action', color: '#e94560', inputs: [{ name:  'exec', type: 'exec' }, { name: 'vx', type: 'number', default: 0 }, { name: 'vy', type: 'number', default: 0 }], outputs: [{ name: 'exec', type:  'exec' }] },
            ApplyForce: { category: 'action', color: '#e94560', inputs: [{ name:  'exec', type: 'exec' }, { name: 'fx', type: 'number', default: 0 }, { name:  'fy', type: 'number', default: -500 }], outputs: [{ name: 'exec', type: 'exec' }] },
            Rotate: { category: 'action', color: '#e94560', inputs: [{ name: 'exec', type: 'exec' }, { name: 'angle', type: 'number', default: 5 }], outputs: [{ name: 'exec', type: 'exec' }] },
            Destroy: { category: 'action', color: '#e94560', inputs: [{ name: 'exec', type: 'exec' }], outputs: [] },
            Spawn: { category: 'action', color: '#e94560', inputs: [{ name:  'exec', type: 'exec' }, { name: 'prefab', type: 'string', default: '' }, { name: 'x', type: 'number', default: 0 }, { name:  'y', type: 'number', default: 0 }], outputs: [{ name: 'exec', type: 'exec' }, { name: 'spawned', type: 'object' }] },
            PlaySound: { category: 'action', color: '#e94560', inputs: [{ name: 'exec', type: 'exec' }, { name: 'sound', type: 'string', default:  'beep' }], outputs: [{ name:  'exec', type: 'exec' }] },
            Log: { category: 'action', color: '#e94560', inputs: [{ name: 'exec', type: 'exec' }, { name: 'message', type: 'string', default: 'Hello!' }], outputs: [{ name:  'exec', type: 'exec' }] },

            // Flow Control
            Branch: { category: 'flow', color: '#ffc107', inputs: [{ name:  'exec', type: 'exec' }, { name: 'condition', type: 'boolean' }], outputs: [{ name:  'true', type: 'exec' }, { name: 'false', type: 'exec' }] },
            Delay: { category: 'flow', color: '#ffc107', inputs: [{ name: 'exec', type: 'exec' }, { name: 'seconds', type: 'number', default: 1 }], outputs:  [{ name: 'exec', type: 'exec' }] },
            Loop: { category: 'flow', color: '#ffc107', inputs: [{ name: 'exec', type: 'exec' }, { name: 'count', type: 'number', default: 5 }], outputs: [{ name: 'loop', type: 'exec' }, { name: 'done', type: 'exec' }, { name: 'index', type: 'number' }] },

            // Math
            Add: { category: 'math', color: '#7b68ee', inputs: [{ name:  'a', type: 'number', default: 0 }, { name: 'b', type: 'number', default: 0 }], outputs: [{ name:  'result', type: 'number' }] },
            Subtract: { category: 'math', color:  '#7b68ee', inputs:  [{ name: 'a', type: 'number', default:  0 }, { name: 'b', type: 'number', default: 0 }], outputs: [{ name: 'result', type: 'number' }] },
            Multiply:  { category: 'math', color: '#7b68ee', inputs: [{ name: 'a', type: 'number', default: 0 }, { name:  'b', type: 'number', default: 0 }], outputs: [{ name: 'result', type: 'number' }] },
            Divide: { category: 'math', color: '#7b68ee', inputs: [{ name: 'a', type: 'number', default: 0 }, { name: 'b', type: 'number', default: 1 }], outputs: [{ name: 'result', type: 'number' }] },
            Random: { category: 'math', color: '#7b68ee', inputs: [{ name: 'min', type: 'number', default: 0 }, { name: 'max', type: 'number', default: 100 }], outputs: [{ name:  'result', type: 'number' }] },

            // Comparison
            Equals: { category: 'comparison', color: '#ff9800', inputs: [{ name:  'a', type: 'any', default: 0 }, { name: 'b', type: 'any', default: 0 }], outputs: [{ name:  'result', type: 'boolean' }] },
            Greater: { category: 'comparison', color: '#ff9800', inputs: [{ name: 'a', type: 'number', default: 0 }, { name: 'b', type:  'number', default: 0 }], outputs: [{ name: 'result', type: 'boolean' }] },
            Less: { category: 'comparison', color: '#ff9800', inputs: [{ name: 'a', type: 'number', default: 0 }, { name: 'b', type: 'number', default: 0 }], outputs: [{ name:  'result', type: 'boolean' }] },

            // Variables
            GetVariable: { category: 'variable', color: '#00bcd4', inputs: [{ name: 'name', type: 'string', default: 'myVar' }], outputs: [{ name: 'value', type:  'any' }] },
            SetVariable: { category: 'variable', color: '#00bcd4', inputs: [{ name: 'exec', type: 'exec' }, { name: 'name', type: 'string', default: 'myVar' }, { name: 'value', type: 'any', default: 0 }], outputs: [{ name: 'exec', type: 'exec' }] },
            GetProperty: { category: 'variable', color: '#00bcd4', inputs: [{ name: 'property', type: 'property', default: 'x' }], outputs: [{ name: 'value', type: 'number' }] }
        };

        // ===== VISUAL SCRIPT NODE CLASS =====
        class VSNode {
            constructor(type, x = 100, y = 100) {
                this.id = `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.type = type;
                this.x = x;
                this.y = y;
                this.definition = NodeDefinitions[type];
                this.inputValues = {};
                this.outputValues = {};

                // Initialize default values
                if (this.definition?.inputs) {
                    this.definition.inputs.forEach(input => {
                        if (input.default !== undefined) {
                            this.inputValues[input.name] = input.default;
                        }
                    });
                }
            }

            toJSON() {
                return {
                    id: this.id,
                    type: this.type,
                    x: this.x,
                    y: this.y,
                    inputValues: { ...this.inputValues }
                };
            }

            static fromJSON(json) {
                const node = new VSNode(json.type, json.x, json.y);
                node.id = json.id;
                node.inputValues = json.inputValues || {};
                return node;
            }
        }

        // ===== VISUAL SCRIPT CONNECTION CLASS =====
        class VSConnection {
            constructor(fromNode, fromPort, toNode, toPort) {
                this.id = `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                this.fromNode = fromNode;
                this.fromPort = fromPort;
                this.toNode = toNode;
                this.toPort = toPort;
            }

            toJSON() {
                return {
                    id:  this.id,
                    fromNode: this.fromNode,
                    fromPort: this.fromPort,
                    toNode:  this.toNode,
                    toPort: this.toPort
                };
            }

            static fromJSON(json) {
                const conn = new VSConnection(json.fromNode, json.fromPort, json.toNode, json.toPort);
                conn.id = json.id;
                return conn;
            }
        }

        // ===== VISUAL SCRIPT EXECUTOR =====
        class ScriptExecutor {
            constructor(gameObject) {
                this.gameObject = gameObject;
                this.nodes = new Map();
                this.connections = [];
                this.delayedExecutions = [];

                // Build node map
                gameObject.nodes.forEach(nodeData => {
                    const node = VSNode.fromJSON(nodeData);
                    this.nodes.set(node.id, node);
                });

                // Build connections
                gameObject.connections.forEach(connData => {
                    this.connections.push(VSConnection.fromJSON(connData));
                });
            }

            getInputValue(node, portName) {
                // Check for connected value first
                const conn = this.connections.find(c => c.toNode === node.id && c.toPort === portName);
                if (conn) {
                    const fromNode = this.nodes.get(conn.fromNode);
                    if (fromNode) {
                        return this.evaluateNode(fromNode, conn.fromPort);
                    }
                }
                // Return local value
                return node.inputValues[portName];
            }

            evaluateNode(node, outputPort = null) {
                const def = node.definition;
                if (! def) return null;

                switch (node.type) {
                    case 'Add':
                        return this.getInputValue(node, 'a') + this.getInputValue(node, 'b');
                    case 'Subtract': 
                        return this.getInputValue(node, 'a') - this.getInputValue(node, 'b');
                    case 'Multiply':
                        return this.getInputValue(node, 'a') * this.getInputValue(node, 'b');
                    case 'Divide':
                        const divisor = this.getInputValue(node, 'b');
                        return divisor !== 0 ? this.getInputValue(node, 'a') / divisor : 0;
                    case 'Random': 
                        const min = this.getInputValue(node, 'min');
                        const max = this.getInputValue(node, 'max');
                        return Math.random() * (max - min) + min;
                    case 'Equals':
                        return this.getInputValue(node, 'a') === this.getInputValue(node, 'b');
                    case 'Greater': 
                        return this.getInputValue(node, 'a') > this.getInputValue(node, 'b');
                    case 'Less':
                        return this.getInputValue(node, 'a') < this.getInputValue(node, 'b');
                    case 'GetVariable':
                        const varName = this.getInputValue(node, 'name');
                        return this.gameObject.variables[varName] ??  Engine.variables[varName] ?? 0;
                    case 'GetProperty':
                        const prop = this.getInputValue(node, 'property');
                        return this.gameObject[prop] ?? 0;
                    case 'OnUpdate':
                        if (outputPort === 'deltaTime') return Engine.deltaTime;
                        return null;
                    default:
                        return node.outputValues[outputPort];
                }
            }

            executeNode(node, context = {}) {
                if (! node || !node.definition) return;

                const def = node.definition;

                switch (node.type) {
                    case 'Move':
                        const mx = this.getInputValue(node, 'x');
                        const my = this.getInputValue(node, 'y');
                        this.gameObject.x += mx * Engine.deltaTime;
                        this.gameObject.y += my * Engine.deltaTime;
                        this.continueExec(node, 'exec');
                        break;

                    case 'SetPosition': 
                        this.gameObject.x = this.getInputValue(node, 'x');
                        this.gameObject.y = this.getInputValue(node, 'y');
                        this.continueExec(node, 'exec');
                        break;

                    case 'SetVelocity':
                        this.gameObject.vx = this.getInputValue(node, 'vx');
                        this.gameObject.vy = this.getInputValue(node, 'vy');
                        this.continueExec(node, 'exec');
                        break;

                    case 'ApplyForce':
                        if (! this.gameObject.isStatic) {
                            this.gameObject.vx += this.getInputValue(node, 'fx') / this.gameObject.mass;
                            this.gameObject.vy += this.getInputValue(node, 'fy') / this.gameObject.mass;
                        }
                        this.continueExec(node, 'exec');
                        break;

                    case 'Rotate': 
                        this.gameObject.rotation += this.getInputValue(node, 'angle');
                        this.continueExec(node, 'exec');
                        break;

                    case 'Destroy':
                        this.gameObject.visible = false;
                        this.gameObject._destroyed = true;
                        break;

                    case 'Log':
                        ConsoleLog(this.getInputValue(node, 'message'), 'log');
                        this.continueExec(node, 'exec');
                        break;

                    case 'SetVariable':
                        const setVarName = this.getInputValue(node, 'name');
                        const setVarValue = this.getInputValue(node, 'value');
                        this.gameObject.variables[setVarName] = setVarValue;
                        this.continueExec(node, 'exec');
                        break;

                    case 'Branch':
                        const condition = this.getInputValue(node, 'condition');
                        if (condition) {
                            this.continueExec(node, 'true');
                        } else {
                            this.continueExec(node, 'false');
                        }
                        break;

                    case 'Delay':
                        const delay = this.getInputValue(node, 'seconds') * 1000;
                        setTimeout(() => {
                            if (Engine.isPlaying) {
                                this.continueExec(node, 'exec');
                            }
                        }, delay);
                        break;

                    case 'Loop':
                        const count = this.getInputValue(node, 'count');
                        for (let i = 0; i < count; i++) {
                            node.outputValues['index'] = i;
                            this.continueExec(node, 'loop');
                        }
                        this.continueExec(node, 'done');
                        break;

                    case 'PlaySound':
                        // Simple beep sound using Web Audio API
                        try {
                            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = audioCtx.createOscillator();
                            const gainNode = audioCtx.createGain();
                            oscillator.connect(gainNode);
                            gainNode.connect(audioCtx.destination);
                            oscillator.frequency.value = 440;
                            oscillator.type = 'sine';
                            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                            oscillator.start(audioCtx.currentTime);
                            oscillator.stop(audioCtx.currentTime + 0.2);
                        } catch (e) {}
                        this.continueExec(node, 'exec');
                        break;

                    case 'Spawn':
                        const prefabName = this.getInputValue(node, 'prefab');
                        const spawnX = this.getInputValue(node, 'x');
                        const spawnY = this.getInputValue(node, 'y');
                        const prefab = Engine.prefabs.find(p => p.name === prefabName);
                        if (prefab) {
                            const spawned = new GameObject({ ... prefab, x: spawnX, y: spawnY });
                            Engine.objects.push(spawned);
                            spawned.saveState();
                            node.outputValues['spawned'] = spawned;
                        }
                        this.continueExec(node, 'exec');
                        break;
                }
            }

            continueExec(fromNode, fromPort) {
                const conns = this.connections.filter(c => c.fromNode === fromNode.id && c.fromPort === fromPort);
                conns.forEach(conn => {
                    const nextNode = this.nodes.get(conn.toNode);
                    if (nextNode) {
                        this.executeNode(nextNode);
                    }
                });
            }

            triggerEvent(eventType, context = {}) {
                this.nodes.forEach(node => {
                    if (node.type === eventType) {
                        // Check conditions
                        if (eventType === 'OnKeyPress' || eventType === 'OnKeyRelease') {
                            const key = node.inputValues['key'];
                            if (context.key !== key && key !== 'Any') return;
                        }
                        if (eventType === 'OnCollision') {
                            const tag = node.inputValues['tag'];
                            if (tag !== 'any' && context.other?.tag !== tag) return;
                            node.outputValues['other'] = context.other;
                        }

                        // Execute connected nodes
                        this.continueExec(node, 'exec');
                    }
                });
            }
        }

        // ===== PHYSICS ENGINE =====
        const Physics = {
            update(dt) {
                const objects = Engine.objects.filter(o => o.physics && !o._destroyed);
                
                // Apply gravity and update velocities
                objects.forEach(obj => {
                    if (!obj.isStatic) {
                        obj.vx += obj.ax * dt;
                        obj.vy += (obj.ay + Engine.gravity.y * obj.gravityScale) * dt;
                        
                        // Apply friction
                        if (obj.grounded) {
                            obj.vx *= (1 - obj.friction);
                        }
                    }
                });
                
                // Update positions
                objects.forEach(obj => {
                    if (!obj.isStatic) {
                        obj.x += obj.vx * dt;
                        obj.y += obj.vy * dt;
                    }
                });
                
                // Reset grounded state before collision detection
                objects.forEach(obj => {
                    if (!obj.isStatic) {
                        obj.grounded = false;
                    }
                });
                
                // Collision detection and resolution
                for (let i = 0; i < objects.length; i++) {
                    for (let j = i + 1; j < objects.length; j++) {
                        const a = objects[i];
                        const b = objects[j];
                        
                        if (a.collidesWith(b)) {
                            this.resolveCollision(a, b);
                            
                            // Trigger collision events
                            if (a.nodes.length > 0) {
                                const executor = new ScriptExecutor(a);
                                executor.triggerEvent('OnCollision', { other: b });
                            }
                            if (b.nodes.length > 0) {
                                const executor = new ScriptExecutor(b);
                                executor.triggerEvent('OnCollision', { other: a });
                            }
                        }
                    }
                }
                
                // Keep objects within bounds
                objects.forEach(obj => {
                    if (!obj.isStatic) {
                        if (obj.y + obj.height > Engine.height) {
                            obj.y = Engine.height - obj.height;
                            obj.vy *= -obj.bounce;
                            obj.grounded = true;
                        }
                        if (obj.y < 0) {
                            obj.y = 0;
                            obj.vy *= -obj.bounce;
                        }
                        if (obj.x < 0) {
                            obj.x = 0;
                            obj.vx *= -obj.bounce;
                        }
                        if (obj.x + obj.width > Engine.width) {
                            obj.x = Engine.width - obj.width;
                            obj.vx *= -obj.bounce;
                        }
                    }
                });
            },
            
            resolveCollision(a, b) {
                if (a.isStatic && b.isStatic) return;
                
                const aBounds = a.getBounds();
                const bBounds = b.getBounds();
                
                // Calculate overlap
                const overlapX = Math.min(aBounds.right - bBounds.left, bBounds.right - aBounds.left);
                const overlapY = Math.min(aBounds.bottom - bBounds.top, bBounds.bottom - aBounds.top);
                
                // Resolve in the smallest overlap direction
                if (overlapX < overlapY) {
                    // Horizontal collision
                    if (aBounds.centerX < bBounds.centerX) {
                        if (!a.isStatic) a.x -= overlapX / (b.isStatic ? 1 : 2);
                        if (!b.isStatic) b.x += overlapX / (a.isStatic ? 1 : 2);
                    } else {
                        if (!a.isStatic) a.x += overlapX / (b.isStatic ? 1 : 2);
                        if (!b.isStatic) b.x -= overlapX / (a.isStatic ? 1 : 2);
                    }
                    // Bounce velocities
                    if (!a.isStatic && !b.isStatic) {
                        const tempVx = a.vx;
                        a.vx = b.vx * a.bounce;
                        b.vx = tempVx * b.bounce;
                    } else if (!a.isStatic) {
                        a.vx *= -a.bounce;
                    } else if (!b.isStatic) {
                        b.vx *= -b.bounce;
                    }
                } else {
                    // Vertical collision
                    if (aBounds.centerY < bBounds.centerY) {
                        if (!a.isStatic) {
                            a.y -= overlapY / (b.isStatic ? 1 : 2);
                            a.grounded = true;
                        }
                        if (!b.isStatic) b.y += overlapY / (a.isStatic ? 1 : 2);
                    } else {
                        if (!a.isStatic) a.y += overlapY / (b.isStatic ? 1 : 2);
                        if (!b.isStatic) {
                            b.y -= overlapY / (a.isStatic ? 1 : 2);
                            b.grounded = true;
                        }
                    }
                    // Bounce velocities
                    if (!a.isStatic && !b.isStatic) {
                        const tempVy = a.vy;
                        a.vy = b.vy * a.bounce;
                        b.vy = tempVy * b.bounce;
                    } else if (!a.isStatic) {
                        a.vy *= -a.bounce;
                    } else if (!b.isStatic) {
                        b.vy *= -b.bounce;
                    }
                }
            }
        };

        // ===== RENDERER =====
        const Renderer = {
            init() {
                Engine.canvas = document.getElementById('game-canvas');
                Engine.ctx = Engine.canvas.getContext('2d');
                Engine.canvas.width = Engine.width;
                Engine.canvas.height = Engine.height;
            },
            
            render() {
                const ctx = Engine.ctx;
                ctx.clearRect(0, 0, Engine.width, Engine.height);
                
                // Background
                ctx.fillStyle = Engine.backgroundColor;
                ctx.fillRect(0, 0, Engine.width, Engine.height);
                
                // Grid
                if (Engine.showGrid && !Engine.isPlaying) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.lineWidth = 1;
                    for (let x = 0; x <= Engine.width; x += Engine.gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, Engine.height);
                        ctx.stroke();
                    }
                    for (let y = 0; y <= Engine.height; y += Engine.gridSize) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(Engine.width, y);
                        ctx.stroke();
                    }
                }
                
                // Sort by layer and render objects
                const sortedObjects = [...Engine.objects].sort((a, b) => a.layer - b.layer);
                sortedObjects.forEach(obj => {
                    if (!obj._destroyed) {
                        obj.render(ctx);
                    }
                });
                
                // Selection highlight
                if (Engine.selectedObject && !Engine.isPlaying) {
                    ctx.strokeStyle = '#e94560';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(
                        Engine.selectedObject.x - 2,
                        Engine.selectedObject.y - 2,
                        Engine.selectedObject.width + 4,
                        Engine.selectedObject.height + 4
                    );
                    ctx.setLineDash([]);
                    
                    // Resize handles
                    const handles = this.getResizeHandles(Engine.selectedObject);
                    ctx.fillStyle = '#e94560';
                    handles.forEach(h => {
                        ctx.fillRect(h.x - 4, h.y - 4, 8, 8);
                    });
                }
            },
            
            getResizeHandles(obj) {
                return [
                    { x: obj.x, y: obj.y, cursor: 'nw-resize' },
                    { x: obj.x + obj.width, y: obj.y, cursor: 'ne-resize' },
                    { x: obj.x, y: obj.y + obj.height, cursor: 'sw-resize' },
                    { x: obj.x + obj.width, y: obj.y + obj.height, cursor: 'se-resize' }
                ];
            }
        };

        // ===== CONSOLE =====
        function ConsoleLog(message, type = 'log') {
            const output = document.getElementById('console-output');
            const line = document.createElement('div');
            line.className = `console-line ${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        // ===== VISUAL SCRIPT EDITOR =====
        const NodeEditor = {
            container: null,
            svg: null,
            nodes: [],
            connections: [],
            selectedNode: null,
            draggedNode: null,
            dragOffset: { x: 0, y: 0 },
            connectingFrom: null,
            panOffset: { x: 0, y: 0 },
            
            init() {
                this.container = document.getElementById('node-editor-container');
                this.svg = document.getElementById('connection-svg');
                this.setupEvents();
            },
            
            setupEvents() {
                this.container.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.container.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.container.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.container.addEventListener('contextmenu', (e) => e.preventDefault());
            },
            
            loadForObject(obj) {
                this.clear();
                if (!obj) return;
                
                this.nodes = obj.nodes.map(n => VSNode.fromJSON(n));
                this.connections = obj.connections.map(c => VSConnection.fromJSON(c));
                
                this.nodes.forEach(node => this.createNodeElement(node));
                this.renderConnections();
                
                document.getElementById('current-object-script').textContent = `Script: ${obj.name}`;
            },
            
            saveToObject(obj) {
                if (!obj) return;
                obj.nodes = this.nodes.map(n => n.toJSON());
                obj.connections = this.connections.map(c => c.toJSON());
            },
            
            clear() {
                this.container.querySelectorAll('.vs-node').forEach(el => el.remove());
                this.svg.innerHTML = '';
                this.nodes = [];
                this.connections = [];
                this.selectedNode = null;
            },
            
            addNode(type, x = 100, y = 100) {
                const node = new VSNode(type, x, y);
                this.nodes.push(node);
                this.createNodeElement(node);
                
                if (Engine.selectedObject) {
                    this.saveToObject(Engine.selectedObject);
                }
                
                return node;
            },
            
            createNodeElement(node) {
                const def = node.definition;
                if (!def) return;
                
                const el = document.createElement('div');
                el.className = `vs-node ${def.category}`;
                el.dataset.nodeId = node.id;
                el.style.left = node.x + 'px';
                el.style.top = node.y + 'px';
                
                // Header
                const header = document.createElement('div');
                header.className = 'vs-node-header';
                header.textContent = node.type;
                el.appendChild(header);
                
                // Content
                const content = document.createElement('div');
                content.className = 'vs-node-content';
                
                // Input ports
                (def.inputs || []).forEach(input => {
                    const row = document.createElement('div');
                    row.className = 'vs-node-row';
                    
                    const port = document.createElement('div');
                    port.className = `vs-port ${input.type === 'exec' ? 'exec' : ''}`;
                    port.dataset.nodeId = node.id;
                    port.dataset.portName = input.name;
                    port.dataset.portType = 'input';
                    
                    const label = document.createElement('span');
                    label.className = 'vs-port-label';
                    label.textContent = input.name;
                    
                    row.appendChild(port);
                    row.appendChild(label);
                    
                    // Add input field for non-exec ports
                    if (input.type !== 'exec') {
                        const inputEl = this.createInputField(node, input);
                        row.appendChild(inputEl);
                    }
                    
                    content.appendChild(row);
                });
                
                // Output ports
                (def.outputs || []).forEach(output => {
                    const row = document.createElement('div');
                    row.className = 'vs-node-row';
                    row.style.justifyContent = 'flex-end';
                    
                    const label = document.createElement('span');
                    label.className = 'vs-port-label';
                    label.textContent = output.name;
                    
                    const port = document.createElement('div');
                    port.className = `vs-port ${output.type === 'exec' ? 'exec' : ''}`;
                    port.dataset.nodeId = node.id;
                    port.dataset.portName = output.name;
                    port.dataset.portType = 'output';
                    
                    row.appendChild(label);
                    row.appendChild(port);
                    content.appendChild(row);
                });
                
                el.appendChild(content);
                this.container.appendChild(el);
            },
            
            createInputField(node, input) {
                let el;
                
                if (input.type === 'key') {
                    el = document.createElement('select');
                    ['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'Any'].forEach(key => {
                        const opt = document.createElement('option');
                        opt.value = key;
                        opt.textContent = key;
                        if (node.inputValues[input.name] === key) opt.selected = true;
                        el.appendChild(opt);
                    });
                } else if (input.type === 'tag') {
                    el = document.createElement('select');
                    ['any', 'player', 'enemy', 'platform', 'ground', 'obstacle', 'collectible', 'trigger', 'none'].forEach(tag => {
                        const opt = document.createElement('option');
                        opt.value = tag;
                        opt.textContent = tag;
                        if (node.inputValues[input.name] === tag) opt.selected = true;
                        el.appendChild(opt);
                    });
                } else if (input.type === 'property') {
                    el = document.createElement('select');
                    ['x', 'y', 'width', 'height', 'rotation', 'vx', 'vy'].forEach(prop => {
                        const opt = document.createElement('option');
                        opt.value = prop;
                        opt.textContent = prop;
                        if (node.inputValues[input.name] === prop) opt.selected = true;
                        el.appendChild(opt);
                    });
                } else {
                    el = document.createElement('input');
                    el.type = input.type === 'number' ? 'number' : 'text';
                    el.value = node.inputValues[input.name] ?? input.default ?? '';
                }
                
                el.addEventListener('change', (e) => {
                    node.inputValues[input.name] = input.type === 'number' ? parseFloat(e.target.value) : e.target.value;
                    if (Engine.selectedObject) {
                        this.saveToObject(Engine.selectedObject);
                    }
                });
                
                return el;
            },
            
            onMouseDown(e) {
                const nodeEl = e.target.closest('.vs-node');
                const portEl = e.target.closest('.vs-port');
                
                if (portEl) {
                    // Start connection
                    this.connectingFrom = {
                        nodeId: portEl.dataset.nodeId,
                        portName: portEl.dataset.portName,
                        portType: portEl.dataset.portType,
                        x: e.clientX,
                        y: e.clientY
                    };
                    e.stopPropagation();
                } else if (nodeEl) {
                    // Start dragging node
                    const node = this.nodes.find(n => n.id === nodeEl.dataset.nodeId);
                    if (node) {
                        this.draggedNode = node;
                        this.dragOffset = {
                            x: e.clientX - node.x,
                            y: e.clientY - node.y
                        };
                        this.selectNode(node);
                    }
                    
                    // Right click to delete
                    if (e.button === 2) {
                        this.deleteNode(nodeEl.dataset.nodeId);
                    }
                }
            },
            
            onMouseMove(e) {
                if (this.draggedNode) {
                    this.draggedNode.x = e.clientX - this.dragOffset.x;
                    this.draggedNode.y = e.clientY - this.dragOffset.y;
                    
                    const el = this.container.querySelector(`[data-node-id="${this.draggedNode.id}"]`);
                    if (el) {
                        el.style.left = this.draggedNode.x + 'px';
                        el.style.top = this.draggedNode.y + 'px';
                    }
                    
                    this.renderConnections();
                }
                
                if (this.connectingFrom) {
                    this.renderConnections(e.clientX, e.clientY);
                }
            },
            
            onMouseUp(e) {
                if (this.connectingFrom) {
                    const portEl = e.target.closest('.vs-port');
                    if (portEl && portEl.dataset.nodeId !== this.connectingFrom.nodeId) {
                        // Complete connection
                        const toNodeId = portEl.dataset.nodeId;
                        const toPortName = portEl.dataset.portName;
                        const toPortType = portEl.dataset.portType;
                        
                        // Validate connection direction
                        if (this.connectingFrom.portType === 'output' && toPortType === 'input') {
                            this.addConnection(
                                this.connectingFrom.nodeId,
                                this.connectingFrom.portName,
                                toNodeId,
                                toPortName
                            );
                        } else if (this.connectingFrom.portType === 'input' && toPortType === 'output') {
                            this.addConnection(
                                toNodeId,
                                toPortName,
                                this.connectingFrom.nodeId,
                                this.connectingFrom.portName
                            );
                        }
                    }
                    this.connectingFrom = null;
                    this.renderConnections();
                }
                
                if (this.draggedNode) {
                    if (Engine.selectedObject) {
                        this.saveToObject(Engine.selectedObject);
                    }
                    this.draggedNode = null;
                }
            },
            
            addConnection(fromNode, fromPort, toNode, toPort) {
                // Remove existing connection to the same input port
                this.connections = this.connections.filter(c => 
                    !(c.toNode === toNode && c.toPort === toPort)
                );
                
                const conn = new VSConnection(fromNode, fromPort, toNode, toPort);
                this.connections.push(conn);
                this.renderConnections();
                
                if (Engine.selectedObject) {
                    this.saveToObject(Engine.selectedObject);
                }
            },
            
            deleteNode(nodeId) {
                this.nodes = this.nodes.filter(n => n.id !== nodeId);
                this.connections = this.connections.filter(c => 
                    c.fromNode !== nodeId && c.toNode !== nodeId
                );
                
                const el = this.container.querySelector(`[data-node-id="${nodeId}"]`);
                if (el) el.remove();
                
                this.renderConnections();
                
                if (Engine.selectedObject) {
                    this.saveToObject(Engine.selectedObject);
                }
            },
            
            selectNode(node) {
                this.container.querySelectorAll('.vs-node').forEach(el => el.classList.remove('selected'));
                if (node) {
                    const el = this.container.querySelector(`[data-node-id="${node.id}"]`);
                    if (el) el.classList.add('selected');
                }
                this.selectedNode = node;
            },
            
            renderConnections(tempX, tempY) {
                this.svg.innerHTML = '';
                const containerRect = this.container.getBoundingClientRect();
                
                this.svg.setAttribute('width', containerRect.width);
                this.svg.setAttribute('height', containerRect.height);
                
                // Render existing connections
                this.connections.forEach(conn => {
                    const fromPort = this.container.querySelector(
                        `[data-node-id="${conn.fromNode}"][data-port-name="${conn.fromPort}"][data-port-type="output"]`
                    );
                    const toPort = this.container.querySelector(
                        `[data-node-id="${conn.toNode}"][data-port-name="${conn.toPort}"][data-port-type="input"]`
                    );
                    
                    if (fromPort && toPort) {
                        const fromRect = fromPort.getBoundingClientRect();
                        const toRect = toPort.getBoundingClientRect();
                        
                        this.drawConnection(
                            fromRect.left + fromRect.width / 2 - containerRect.left,
                            fromRect.top + fromRect.height / 2 - containerRect.top,
                            toRect.left + toRect.width / 2 - containerRect.left,
                            toRect.top + toRect.height / 2 - containerRect.top
                        );
                        
                        fromPort.classList.add('connected');
                        toPort.classList.add('connected');
                    }
                });
                
                // Render temporary connection
                if (this.connectingFrom && tempX !== undefined) {
                    const fromPort = this.container.querySelector(
                        `[data-node-id="${this.connectingFrom.nodeId}"][data-port-name="${this.connectingFrom.portName}"]`
                    );
                    if (fromPort) {
                        const fromRect = fromPort.getBoundingClientRect();
                        this.drawConnection(
                            fromRect.left + fromRect.width / 2 - containerRect.left,
                            fromRect.top + fromRect.height / 2 - containerRect.top,
                            tempX - containerRect.left,
                            tempY - containerRect.top,
                            true
                        );
                    }
                }
            },
            
            drawConnection(x1, y1, x2, y2, isTemp = false) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const midX = (x1 + x2) / 2;
                const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
                path.setAttribute('d', d);
                path.setAttribute('stroke', isTemp ? '#ffffff' : '#e94560');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                if (isTemp) {
                    path.setAttribute('stroke-dasharray', '5,5');
                }
                this.svg.appendChild(path);
            }
        };

        // ===== UI MANAGER =====
        const UI = {
            init() {
                this.setupToolbar();
                this.setupPalette();
                this.setupCanvas();
                this.setupInspector();
                this.setupBottomPanel();
                this.setupSettings();
                NodeEditor.init();
            },
            
            setupToolbar() {
                // Tab switching
                document.getElementById('tab-scene').addEventListener('click', () => this.switchView('scene'));
                document.getElementById('tab-visual').addEventListener('click', () => this.switchView('visual'));
                
                // Play/Stop
                document.getElementById('btn-play').addEventListener('click', () => GameLoop.start());
                document.getElementById('btn-stop').addEventListener('click', () => GameLoop.stop());
                document.getElementById('btn-stop-play').addEventListener('click', () => GameLoop.stop());
                document.getElementById('btn-restart-play').addEventListener('click', () => {
                    GameLoop.stop();
                    GameLoop.start();
                });
                
                // Grid/Snap
                document.getElementById('btn-grid').addEventListener('click', function() {
                    Engine.showGrid = !Engine.showGrid;
                    this.classList.toggle('active', Engine.showGrid);
                    Renderer.render();
                });
                
                document.getElementById('btn-snap').addEventListener('click', function() {
                    Engine.snapToGrid = !Engine.snapToGrid;
                    this.classList.toggle('active', Engine.snapToGrid);
                });
                
                // Save/Load
                document.getElementById('btn-new').addEventListener('click', () => this.newProject());
                document.getElementById('btn-save').addEventListener('click', () => this.saveProject());
                document.getElementById('btn-load').addEventListener('click', () => document.getElementById('file-input').click());
                document.getElementById('file-input').addEventListener('change', (e) => this.loadProject(e));
                
                // Node editor buttons
                document.getElementById('btn-add-node').addEventListener('click', () => {
                    const type = document.getElementById('node-type-select').value;
                    NodeEditor.addNode(type, 200, 200);
                });
                
                document.getElementById('btn-clear-nodes').addEventListener('click', () => {
                    if (confirm('Clear all nodes for this object?')) {
                        NodeEditor.clear();
                        if (Engine.selectedObject) {
                            NodeEditor.saveToObject(Engine.selectedObject);
                        }
                    }
                });
                
                // Zoom controls
                document.getElementById('btn-zoom-in').addEventListener('click', () => this.zoom(0.1));
                document.getElementById('btn-zoom-out').addEventListener('click', () => this.zoom(-0.1));
                document.getElementById('btn-zoom-reset').addEventListener('click', () => {
                    Engine.zoom = 1;
                    this.updateZoom();
                });
            },
            
            switchView(view) {
                document.getElementById('tab-scene').classList.toggle('active', view === 'scene');
                document.getElementById('tab-visual').classList.toggle('active', view === 'visual');
                document.getElementById('scene-view').classList.toggle('active', view === 'scene');
                document.getElementById('visual-script-view').classList.toggle('active', view === 'visual');
                
                if (view === 'visual' && Engine.selectedObject) {
                    NodeEditor.loadForObject(Engine.selectedObject);
                }
            },
            
            zoom(delta) {
                Engine.zoom = Math.max(0.25, Math.min(2, Engine.zoom + delta));
                this.updateZoom();
            },
            
            updateZoom() {
                Engine.canvas.style.transform = `translate(-50%, -50%) scale(${Engine.zoom})`;
                document.getElementById('zoom-level').textContent = Math.round(Engine.zoom * 100) + '%';
            },
            
            setupPalette() {
                const content = document.getElementById('palette-content');
                
                // Palette tabs
                document.querySelectorAll('.palette-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.palette-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        this.renderPalette(tab.dataset.tab);
                    });
                });
                
                this.renderPalette('objects');
            },
            
            renderPalette(type) {
                const content = document.getElementById('palette-content');
                content.innerHTML = '';
                
                const items = type === 'objects' ? PaletteObjects : Engine.prefabs;
                
                items.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'palette-item';
                    el.draggable = true;
                    el.innerHTML = `
                        <div class="palette-icon" style="background: ${item.color}">${item.icon}</div>
                        <div class="palette-info">
                            <h4>${item.name}</h4>
                            <span>${item.type}</span>
                        </div>
                    `;
                    
                    el.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('application/json', JSON.stringify(item));
                    });
                    
                    content.appendChild(el);
                });
                
                if (type === 'prefabs') {
                    const addBtn = document.createElement('button');
                    addBtn.className = 'full-width-btn';
                    addBtn.textContent = '+ Create Prefab from Selection';
                    addBtn.addEventListener('click', () => this.createPrefab());
                    content.appendChild(addBtn);
                }
            },
            
            createPrefab() {
                if (!Engine.selectedObject) {
                    ConsoleLog('Select an object first to create a prefab', 'warn');
                    return;
                }
                
                const name = prompt('Enter prefab name:', Engine.selectedObject.name + '_prefab');
                if (name) {
                    const prefab = { ...Engine.selectedObject.toJSON(), name };
                    Engine.prefabs.push(prefab);
                    this.renderPalette('prefabs');
                    ConsoleLog(`Prefab "${name}" created`, 'success');
                }
            },
            
            setupCanvas() {
                const container = document.getElementById('canvas-container');
                const canvas = Engine.canvas;
                
                let isDragging = false;
                let isResizing = false;
                let resizeHandle = null;
                let startX, startY, startObjX, startObjY, startWidth, startHeight;
                
                container.addEventListener('dragover', (e) => e.preventDefault());
                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const data = JSON.parse(e.dataTransfer.getData('application/json'));
                    const rect = canvas.getBoundingClientRect();
                    
                    let x = (e.clientX - rect.left) / Engine.zoom;
                    let y = (e.clientY - rect.top) / Engine.zoom;
                    
                    if (Engine.snapToGrid) {
                        x = Math.round(x / Engine.gridSize) * Engine.gridSize;
                        y = Math.round(y / Engine.gridSize) * Engine.gridSize;
                    }
                    
                    const obj = new GameObject({
                        ...data,
                        x, y,
                        name: data.name + '_' + Engine.nextId
                    });
                    
                    Engine.objects.push(obj);
                    this.selectObject(obj);
                    this.updateHierarchy();
                    Renderer.render();
                    ConsoleLog(`Created ${obj.name}`, 'success');
                });
                
                canvas.addEventListener('mousedown', (e) => {
                    if (Engine.isPlaying) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / Engine.zoom;
                    const y = (e.clientY - rect.top) / Engine.zoom;
                    
                    // Check resize handles first
                    if (Engine.selectedObject) {
                        const handles = Renderer.getResizeHandles(Engine.selectedObject);
                        for (const handle of handles) {
                            if (Math.abs(x - handle.x) < 8 && Math.abs(y - handle.y) < 8) {
                                isResizing = true;
                                resizeHandle = handle.cursor;
                                startX = x;
                                startY = y;
                                startObjX = Engine.selectedObject.x;
                                startObjY = Engine.selectedObject.y;
                                startWidth = Engine.selectedObject.width;
                                startHeight = Engine.selectedObject.height;
                                return;
                            }
                        }
                    }
                    
                    // Check object selection
                    const clicked = [...Engine.objects].reverse().find(obj => obj.containsPoint(x, y));
                    
                    if (clicked) {
                        this.selectObject(clicked);
                        isDragging = true;
                        startX = x - clicked.x;
                        startY = y - clicked.y;
                    } else {
                        this.selectObject(null);
                    }
                    
                    Renderer.render();
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (Engine.isPlaying) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left) / Engine.zoom;
                    const y = (e.clientY - rect.top) / Engine.zoom;
                    
                    if (isDragging && Engine.selectedObject) {
                        let newX = x - startX;
                        let newY = y - startY;
                        
                        if (Engine.snapToGrid) {
                            newX = Math.round(newX / Engine.gridSize) * Engine.gridSize;
                            newY = Math.round(newY / Engine.gridSize) * Engine.gridSize;
                        }
                        
                        Engine.selectedObject.x = newX;
                        Engine.selectedObject.y = newY;
                        this.updateInspector();
                        Renderer.render();
                    }
                    
                    if (isResizing && Engine.selectedObject) {
                        const dx = x - startX;
                        const dy = y - startY;
                        
                        if (resizeHandle.includes('e')) {
                            Engine.selectedObject.width = Math.max(16, startWidth + dx);
                        }
                        if (resizeHandle.includes('w')) {
                            Engine.selectedObject.x = startObjX + dx;
                            Engine.selectedObject.width = Math.max(16, startWidth - dx);
                        }
                        if (resizeHandle.includes('s')) {
                            Engine.selectedObject.height = Math.max(16, startHeight + dy);
                        }
                        if (resizeHandle.includes('n')) {
                            Engine.selectedObject.y = startObjY + dy;
                            Engine.selectedObject.height = Math.max(16, startHeight - dy);
                        }
                        
                        this.updateInspector();
                        Renderer.render();
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                    isResizing = false;
                    resizeHandle = null;
                });
                
                // Context menu
                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (Engine.selectedObject && !Engine.isPlaying) {
                        const menu = document.getElementById('context-menu');
                        menu.style.left = e.clientX + 'px';
                        menu.style.top = e.clientY + 'px';
                        menu.classList.add('active');
                    }
                });
                
                document.addEventListener('click', () => {
                    document.getElementById('context-menu').classList.remove('active');
                });
                
                document.querySelectorAll('.context-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const action = item.dataset.action;
                        if (!Engine.selectedObject) return;
                        
                        switch (action) {
                            case 'duplicate':
                                const dupe = new GameObject(Engine.selectedObject.toJSON());
                                dupe.x += 20;
                                dupe.y += 20;
                                dupe.name = Engine.selectedObject.name + '_copy';
                                Engine.objects.push(dupe);
                                this.selectObject(dupe);
                                this.updateHierarchy();
                                break;
                            case 'delete':
                                Engine.objects = Engine.objects.filter(o => o !== Engine.selectedObject);
                                this.selectObject(null);
                                this.updateHierarchy();
                                break;
                            case 'bring-front':
                                Engine.selectedObject.layer = Math.max(...Engine.objects.map(o => o.layer)) + 1;
                                break;
                            case 'send-back':
                                Engine.selectedObject.layer = Math.min(...Engine.objects.map(o => o.layer)) - 1;
                                break;
                        }
                        Renderer.render();
                    });
                });
            },
            
            selectObject(obj) {
                Engine.selectedObject = obj;
                this.updateInspector();
                this.updateHierarchy();
                
                if (document.getElementById('visual-script-view').classList.contains('active')) {
                    NodeEditor.loadForObject(obj);
                }
            },
            
            setupInspector() {
                // Initial state handled by updateInspector
            },
            
            updateInspector() {
                const noSelection = document.getElementById('no-selection');
                const inspector = document.getElementById('object-inspector');
                
                if (!Engine.selectedObject) {
                    noSelection.style.display = 'block';
                    inspector.style.display = 'none';
                    return;
                }
                
                noSelection.style.display = 'none';
                inspector.style.display = 'block';
                
                const obj = Engine.selectedObject;
                
                inspector.innerHTML = `
                    <div class="inspector-section">
                        <h3>General</h3>
                        <div class="property-row">
                            <label>Name</label>
                            <input type="text" id="prop-name" value="${obj.name}">
                        </div>
                        <div class="property-row">
                            <label>Tag</label>
                            <select id="prop-tag">
                                ${['none', 'player', 'enemy', 'platform', 'ground', 'obstacle', 'collectible', 'trigger'].map(t => 
                                    `<option value="${t}" ${obj.tag === t ? 'selected' : ''}>${t}</option>`
                                ).join('')}
                            </select>
                        </div>
                        <div class="property-row">
                            <label>Visible</label>
                            <input type="checkbox" id="prop-visible" ${obj.visible ? 'checked' : ''}>
                        </div>
                        <div class="property-row">
                            <label>Layer</label>
                            <input type="number" id="prop-layer" value="${obj.layer}">
                        </div>
                    </div>
                    
                    <div class="inspector-section">
                        <h3>Transform</h3>
                        <div class="property-row">
                            <label>X</label>
                            <input type="number" id="prop-x" value="${Math.round(obj.x)}">
                        </div>
                        <div class="property-row">
                            <label>Y</label>
                            <input type="number" id="prop-y" value="${Math.round(obj.y)}">
                        </div>
                        <div class="property-row">
                            <label>Width</label>
                            <input type="number" id="prop-width" value="${Math.round(obj.width)}">
                        </div>
                        <div class="property-row">
                            <label>Height</label>
                            <input type="number" id="prop-height" value="${Math.round(obj.height)}">
                        </div>
                        <div class="property-row">
                            <label>Rotation</label>
                            <input type="number" id="prop-rotation" value="${obj.rotation}">
                        </div>
                    </div>
                    
                    <div class="inspector-section">
                        <h3>Appearance</h3>
                        <div class="property-row">
                            <label>Color</label>
                            <input type="color" id="prop-color" value="${obj.color}">
                        </div>
                        <div class="property-row">
                            <label>Opacity</label>
                            <input type="range" id="prop-opacity" min="0" max="1" step="0.1" value="${obj.opacity}">
                        </div>
                        ${obj.type === 'text' ? `
                        <div class="property-row">
                            <label>Text</label>
                            <input type="text" id="prop-text" value="${obj.text}">
                        </div>
                        ` : ''}
                    </div>
                    
                    <div class="inspector-section">
                        <h3>Physics</h3>
                        <div class="property-row">
                            <label>Enabled</label>
                            <input type="checkbox" id="prop-physics" ${obj.physics ? 'checked' : ''}>
                        </div>
                        <div class="property-row">
                            <label>Static</label>
                            <input type="checkbox" id="prop-static" ${obj.isStatic ? 'checked' : ''}>
                        </div>
                        <div class="property-row">
                            <label>Mass</label>
                            <input type="number" id="prop-mass" value="${obj.mass}" step="0.1">
                        </div>
                        <div class="property-row">
                            <label>Friction</label>
                            <input type="number" id="prop-friction" value="${obj.friction}" step="0.1" min="0" max="1">
                        </div>
                        <div class="property-row">
                            <label>Bounce</label>
                            <input type="number" id="prop-bounce" value="${obj.bounce}" step="0.1" min="0" max="1">
                        </div>
                        <div class="property-row">
                            <label>Gravity Scale</label>
                            <input type="number" id="prop-gravity" value="${obj.gravityScale}" step="0.1">
                        </div>
                    </div>
                    
                    <button class="full-width-btn danger" id="btn-delete-object">üóëÔ∏è Delete Object</button>
                `;
                
                // Bind events
                const bindProp = (id, prop, transform = v => v) => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.addEventListener('change', () => {
                            obj[prop] = transform(el.type === 'checkbox' ? el.checked : el.value);
                            Renderer.render();
                            this.updateHierarchy();
                        });
                    }
                };
                
                bindProp('prop-name', 'name');
                bindProp('prop-tag', 'tag');
                bindProp('prop-visible', 'visible');
                bindProp('prop-layer', 'layer', parseFloat);
                bindProp('prop-x', 'x', parseFloat);
                bindProp('prop-y', 'y', parseFloat);
                bindProp('prop-width', 'width', parseFloat);
                bindProp('prop-height', 'height', parseFloat);
                bindProp('prop-rotation', 'rotation', parseFloat);
                bindProp('prop-color', 'color');
                bindProp('prop-opacity', 'opacity', parseFloat);
                bindProp('prop-text', 'text');
                bindProp('prop-physics', 'physics');
                bindProp('prop-static', 'isStatic');
                bindProp('prop-mass', 'mass', parseFloat);
                bindProp('prop-friction', 'friction', parseFloat);
                bindProp('prop-bounce', 'bounce', parseFloat);
                bindProp('prop-gravity', 'gravityScale', parseFloat);
                
                document.getElementById('btn-delete-object').addEventListener('click', () => {
                    Engine.objects = Engine.objects.filter(o => o !== Engine.selectedObject);
                    this.selectObject(null);
                    this.updateHierarchy();
                    Renderer.render();
                });
            },
            
            setupBottomPanel() {
                // Panel tabs
                document.querySelectorAll('.panel-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.bottom-content').forEach(c => c.classList.remove('active'));
                        tab.classList.add('active');
                        document.getElementById(tab.dataset.panel + '-panel').classList.add('active');
                    });
                });
                
                // Console
                document.getElementById('btn-console-clear').addEventListener('click', () => {
                    document.getElementById('console-output').innerHTML = '';
                });
                
                document.getElementById('console-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const input = e.target.value;
                        ConsoleLog('> ' + input);
                        try {
                            const result = eval(input);
                            if (result !== undefined) {
                                ConsoleLog(String(result), 'success');
                            }
                        } catch (err) {
                            ConsoleLog(err.message, 'error');
                        }
                        e.target.value = '';
                    }
                });
                
                this.updateHierarchy();
            },
            
            updateHierarchy() {
                const list = document.getElementById('hierarchy-list');
                list.innerHTML = '';
                
                Engine.objects.forEach(obj => {
                    const item = document.createElement('div');
                    item.className = `hierarchy-item ${obj === Engine.selectedObject ? 'selected' : ''}`;
                    item.innerHTML = `<span>${obj.icon}</span> ${obj.name}`;
                    item.addEventListener('click', () => {
                        this.selectObject(obj);
                        Renderer.render();
                    });
                    list.appendChild(item);
                });
            },
            
            setupSettings() {
                const content = document.getElementById('settings-content');
                content.innerHTML = `
                    <div class="setting-item">
                        <label>Canvas Width</label>
                        <input type="number" id="setting-width" value="${Engine.width}">
                    </div>
                    <div class="setting-item">
                        <label>Canvas Height</label>
                        <input type="number" id="setting-height" value="${Engine.height}">
                    </div>
                    <div class="setting-item">
                        <label>Background Color</label>
                        <input type="color" id="setting-bg" value="${Engine.backgroundColor}">
                    </div>
                    <div class="setting-item">
                        <label>Grid Size</label>
                        <input type="number" id="setting-grid" value="${Engine.gridSize}">
                    </div>
                    <div class="setting-item">
                        <label>Gravity X</label>
                        <input type="number" id="setting-gravity-x" value="${Engine.gravity.x}">
                    </div>
                    <div class="setting-item">
                        <label>Gravity Y</label>
                        <input type="number" id="setting-gravity-y" value="${Engine.gravity.y}">
                    </div>
                `;
                
                document.getElementById('setting-width').addEventListener('change', (e) => {
                    Engine.width = parseInt(e.target.value);
                    Engine.canvas.width = Engine.width;
                    Renderer.render();
                });
                
                document.getElementById('setting-height').addEventListener('change', (e) => {
                    Engine.height = parseInt(e.target.value);
                    Engine.canvas.height = Engine.height;
                    Renderer.render();
                });
                
                document.getElementById('setting-bg').addEventListener('change', (e) => {
                    Engine.backgroundColor = e.target.value;
                    Renderer.render();
                });
                
                document.getElementById('setting-grid').addEventListener('change', (e) => {
                    Engine.gridSize = parseInt(e.target.value);
                    Renderer.render();
                });
                
                document.getElementById('setting-gravity-x').addEventListener('change', (e) => {
                    Engine.gravity.x = parseFloat(e.target.value);
                });
                
                document.getElementById('setting-gravity-y').addEventListener('change', (e) => {
                    Engine.gravity.y = parseFloat(e.target.value);
                });
            },
            
            newProject() {
                if (confirm('Create a new project? All unsaved changes will be lost.')) {
                    Engine.objects = [];
                    Engine.prefabs = [];
                    Engine.variables = {};
                    Engine.selectedObject = null;
                    this.updateHierarchy();
                    this.updateInspector();
                    NodeEditor.clear();
                    Renderer.render();
                    ConsoleLog('New project created', 'success');
                }
            },
            
            saveProject() {
                const project = {
                    version: '1.0',
                    settings: {
                        width: Engine.width,
                        height: Engine.height,
                        backgroundColor: Engine.backgroundColor,
                        gridSize: Engine.gridSize,
                        gravity: Engine.gravity
                    },
                    objects: Engine.objects.map(o => o.toJSON()),
                    prefabs: Engine.prefabs,
                    variables: Engine.variables
                };
                
                const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'gameforge-project.json';
                a.click();
                URL.revokeObjectURL(url);
                
                ConsoleLog('Project saved!', 'success');
            },
            
            loadProject(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const project = JSON.parse(event.target.result);
                        
                        // Load settings
                        if (project.settings) {
                            Engine.width = project.settings.width || 800;
                            Engine.height = project.settings.height || 600;
                            Engine.backgroundColor = project.settings.backgroundColor || '#1a1a2e';
                            Engine.gridSize = project.settings.gridSize || 32;
                            Engine.gravity = project.settings.gravity || { x: 0, y: 980 };
                            
                            Engine.canvas.width = Engine.width;
                            Engine.canvas.height = Engine.height;
                            this.setupSettings();
                        }
                        
                        // Load objects
                        Engine.objects = (project.objects || []).map(o => GameObject.fromJSON(o));
                        Engine.nextId = Math.max(...Engine.objects.map(o => o.id), 0) + 1;
                        
                        // Load prefabs and variables
                        Engine.prefabs = project.prefabs || [];
                        Engine.variables = project.variables || {};
                        
                        this.selectObject(null);
                        this.updateHierarchy();
                        this.renderPalette('prefabs');
                        Renderer.render();
                        
                        ConsoleLog('Project loaded!', 'success');
                    } catch (err) {
                        ConsoleLog('Error loading project: ' + err.message, 'error');
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }
        };

        // ===== GAME LOOP =====
        const GameLoop = {
            animationFrame: null,
            executors: [],
            
            start() {
                if (Engine.isPlaying) return;
                
                Engine.isPlaying = true;
                Engine.keys = {};
                
                // Save object states
                Engine.objects.forEach(obj => obj.saveState());
                
                // Create script executors
                this.executors = Engine.objects.map(obj => ({
                    object: obj,
                    executor: new ScriptExecutor(obj)
                }));
                
                // Trigger OnStart events
                this.executors.forEach(({ executor }) => {
                    executor.triggerEvent('OnStart');
                });
                
                // Setup play mode UI
                document.getElementById('btn-play').disabled = true;
                document.getElementById('btn-stop').disabled = false;
                document.getElementById('play-overlay').classList.add('active');
                
                // Setup play canvas
                const playCanvas = document.getElementById('play-canvas');
                playCanvas.width = Engine.width;
                playCanvas.height = Engine.height;
                
                Engine.lastTime = performance.now();
                ConsoleLog('Game started!', 'success');
                
                this.loop();
            },
            
            stop() {
                if (!Engine.isPlaying) return;
                
                Engine.isPlaying = false;
                cancelAnimationFrame(this.animationFrame);
                
                // Restore object states
                Engine.objects.forEach(obj => {
                    obj.restoreState();
                    obj._destroyed = false;
                });
                
                // Reset UI
                document.getElementById('btn-play').disabled = false;
                document.getElementById('btn-stop').disabled = true;
                document.getElementById('play-overlay').classList.remove('active');
                
                Renderer.render();
                ConsoleLog('Game stopped!', 'log');
            },
            
            loop() {
                if (!Engine.isPlaying) return;
                
                const now = performance.now();
                Engine.deltaTime = Math.min((now - Engine.lastTime) / 1000, 0.1);
                Engine.lastTime = now;
                
                // Update scripts
                this.executors.forEach(({ object, executor }) => {
                    if (!object._destroyed) {
                        executor.triggerEvent('OnUpdate');
                    }
                });
                
                // Update physics
                Physics.update(Engine.deltaTime);
                
                // Render to play canvas
                const playCanvas = document.getElementById('play-canvas');
                const ctx = playCanvas.getContext('2d');
                
                ctx.clearRect(0, 0, Engine.width, Engine.height);
                ctx.fillStyle = Engine.backgroundColor;
                ctx.fillRect(0, 0, Engine.width, Engine.height);
                
                const sortedObjects = [...Engine.objects]
                    .filter(o => !o._destroyed)
                    .sort((a, b) => a.layer - b.layer);
                    
                sortedObjects.forEach(obj => obj.render(ctx));
                
                this.animationFrame = requestAnimationFrame(() => this.loop());
            }
        };

        // ===== KEYBOARD INPUT =====
        document.addEventListener('keydown', (e) => {
            if (!Engine.isPlaying) return;
            
            const key = e.code;
            if (!Engine.keys[key]) {
                Engine.keys[key] = true;
                GameLoop.executors.forEach(({ object, executor }) => {
                    if (!object._destroyed) {
                        executor.triggerEvent('OnKeyPress', { key });
                    }
                });
            }
        });

        document.addEventListener('keyup', (e) => {
            if (!Engine.isPlaying) return;
            
            const key = e.code;
            Engine.keys[key] = false;
            GameLoop.executors.forEach(({ object, executor }) => {
                if (!object._destroyed) {
                    executor.triggerEvent('OnKeyRelease', { key });
                }
            });
        });

        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', () => {
            Renderer.init();
            UI.init();
            Renderer.render();
            
            ConsoleLog('GameForge 2D Engine initialized!', 'success');
            ConsoleLog('Drag objects from the palette to create your game.', 'log');
        });
    </script>
</body>
</html> 